---
title: Project Workflow
description: The seven-step LlamaIndex workflow that transforms a raw HN comment into structured, scored, and embedded project data.
navigation.icon: i-lucide-git-branch
---

# Project Workflow

The `WaywoProjectWorkflow` is a LlamaIndex event-driven workflow that processes a single HN comment through seven sequential steps. Each step emits a Pydantic event consumed by the next step, building up richer project data as it progresses.

## Architecture

The workflow uses LlamaIndex's `Workflow` base class with the `@step` decorator. Each step is an async method that receives an event and returns the next event in the chain:

```
StartEvent
  -> CommentInputEvent
    -> ExtractedProjectEvent
      -> ValidatedProjectEvent
        -> URLsFetchedEvent
          -> MetadataGeneratedEvent
            -> ScoredProjectEvent
              -> EmbeddingGeneratedEvent
                -> StopEvent
```

For multi-project comments, the extract step emits multiple `ExtractedProjectEvent` instances via `ctx.send_event()`, and the finalize step collects all results before emitting a single `StopEvent`.

## Workflow Usage

```python
workflow = WaywoProjectWorkflow(timeout=180)
result = await workflow.run(
    comment_id=12345,
    comment_text="I'm building an AI-powered...",
    comment_author="user123",
    comment_time=1700000000,
    parent_post_id=46264491,
)
```

The result is a dict containing all extracted projects, their metadata, and workflow logs.

## The Seven Steps

### Step 1: Extract Projects

**Event:** `CommentInputEvent` -> `ExtractedProjectEvent`

The LLM analyzes the comment text to identify distinct projects. Most comments describe one project, but some list multiple. The LLM returns a JSON array of project text segments.

- Deleted, removed, or dead comments are caught early and passed through as-is
- If JSON parsing fails, the full comment text is treated as a single project
- Multi-project comments emit additional events via `ctx.send_event()` for parallel processing

### Step 2: Validate Project

**Event:** `ExtractedProjectEvent` -> `ValidatedProjectEvent`

The LLM determines whether the extracted text describes a real, tangible project. This filters out noise that is common in these threads.

**Accepted:** software, hardware, creative works, open-source libraries, startups, technical craft projects

**Filtered:** personal life activities, general learning without building, questions, job hunting, vague statements

Quick heuristic checks run first (deleted text, text shorter than 20 characters) before the LLM call.

### Step 3: Fetch URLs

**Event:** `ValidatedProjectEvent` -> `URLsFetchedEvent`

URLs are extracted from the project text and scraped via Firecrawl to gather additional context. This step does not use an LLM.

- URLs are validated and deduplicated by the `firecrawl_client`
- Up to 5 URLs are scraped per project
- URL fetching is skipped for invalid projects
- Failed fetches are recorded in `url_errors` but do not halt the workflow

### Step 4: Generate Metadata

**Event:** `URLsFetchedEvent` -> `MetadataGeneratedEvent`

The LLM generates structured metadata using both the comment text and any scraped URL content:

| Field               | Description                                      |
|---------------------|--------------------------------------------------|
| `title`             | Project name, or a concise descriptive title      |
| `short_description` | 5--10 word summary                                |
| `description`       | 1--2 sentence explanation                         |
| `hashtags`          | 3--5 lowercase tags (e.g., `ai`, `python`, `saas`) |
| `url_summaries`     | Per-URL content summaries                         |

URL content is truncated to 2000 characters per URL before being included in the prompt. Hashtags are normalized to lowercase and capped at 5 tags.

### Step 5: Score Project

**Event:** `MetadataGeneratedEvent` -> `ScoredProjectEvent`

The LLM rates the project on two dimensions:

**Idea Score (1--10)**
- 1--2: Very weak, no clear value proposition
- 3--4: Basic, nothing novel
- 5--6: Decent, addresses a real need
- 7--8: Good, clear value, interesting approach
- 9--10: Excellent, innovative, strong market potential

**Complexity Score (1--10)**
- 1--2: Very simple, could be built in a day
- 3--4: Simple, basic features
- 5--6: Moderate, multiple components
- 7--8: Complex, significant engineering
- 9--10: Highly complex, cutting-edge technology

Scores are clamped to the 1--10 range. Invalid projects receive a default score of 1.

### Step 6: Generate Embedding

**Event:** `ScoredProjectEvent` -> `EmbeddingGeneratedEvent`

A 4096-dimensional vector embedding is generated via the NVIDIA embedding service. The embedding text is a combination of the project's title, description, and hashtags for richer semantic representation.

- Only valid projects receive embeddings
- Embedding generation is optional -- failures are logged but do not stop the workflow
- The embedding is stored alongside the project in SQLite for later vector search

### Step 7: Finalize

**Event:** `EmbeddingGeneratedEvent` -> `StopEvent`

The finalize step collects processed project data and checks whether all projects from the comment have completed (relevant for multi-project comments). It returns a `StopEvent` with the full result:

```python
{
    "comment_id": 12345,
    "total_projects": 2,
    "projects": [ ... ],
    "logs": [ ... ],
}
```

After the workflow completes, the calling task (`process_waywo_comment`) saves valid projects to the database and marks the comment as processed.

## Error Handling

Each step follows the same pattern for LLM calls:

1. Call the LLM with a structured prompt
2. Parse the JSON response (stripping any markdown code block wrappers)
3. On failure, log a warning and continue with sensible defaults

This ensures that a single malformed LLM response does not abort the entire workflow. The `process_waywo_comment` Celery task wraps the workflow with retry logic (up to 3 retries with exponential backoff) for transient failures.
