---
title: Adding Features
description: Common patterns for extending waywo -- new API endpoints, workflow steps, frontend pages, and model integrations.
navigation.icon: i-lucide-plus-circle
---

# Adding Features

This page covers the most common extension patterns. Each section walks through where to add code and what files to touch.

## Adding an API Endpoint

**Files to modify**: `src/main.py`, `src/models.py`, `src/db_client.py`

### 1. Define the Pydantic model

Add request/response models in `src/models.py`:

```python
class MyNewRequest(BaseModel):
    name: str = Field(..., min_length=1)
    limit: int = Field(default=10, ge=1, le=100)
```

### 2. Add database operations (if needed)

Add CRUD functions in `src/db_client.py`. All database functions use the SQLAlchemy session from `src/database.py`:

```python
def get_my_data(limit: int = 10) -> list[MyModel]:
    with get_session() as session:
        return session.query(MyModel).limit(limit).all()
```

### 3. Register the route

Add the endpoint in `src/main.py`. Group related endpoints under a common tag:

```python
@app.get("/api/my-endpoint", tags=["my-feature"])
async def my_endpoint(limit: int = 10):
    """Docstring shown in Swagger UI."""
    results = get_my_data(limit=limit)
    return {"results": [r.model_dump() for r in results]}
```

The endpoint is immediately available in Swagger UI at `/docs` after a server reload.

## Adding a Workflow Step

**Files to modify**: `src/workflows/events.py`, `src/workflows/waywo_project_workflow.py`, `src/workflows/prompts.py`

### 1. Define the event

Create a new Pydantic event class in `src/workflows/events.py`. Events carry data between steps:

```python
class MyNewEvent(Event):
    """Emitted after my new processing step."""
    comment_id: int
    my_field: str
    # ... carry forward fields from the previous event
```

### 2. Add the prompt template (if LLM-powered)

Add the template and builder function in `src/workflows/prompts.py`:

```python
MY_STEP_TEMPLATE = """Analyze the following...
{input_text}
Return ONLY valid JSON..."""

def my_step_prompt(input_text: str) -> str:
    return MY_STEP_TEMPLATE.format(input_text=input_text)
```

### 3. Implement the step

Add a `@step`-decorated method to the workflow class in the appropriate workflow file:

```python
@step
async def my_new_step(self, ctx: Context, ev: PreviousEvent) -> MyNewEvent:
    prompt = my_step_prompt(ev.input_text)
    response = await self.llm.acomplete(prompt)
    # Parse response, build event
    return MyNewEvent(comment_id=ev.comment_id, my_field=parsed_result)
```

### 4. Register in WORKFLOW_STEPS

Add an entry to the `WORKFLOW_STEPS` list in `src/workflows/prompts.py` so the step appears on the `/prompts` page:

```python
{
    "step": 9,
    "name": "my_new_step",
    "title": "My New Step",
    "description": "What this step does.",
    "workflow": "WaywoProjectWorkflow",
    "input_event": "PreviousEvent",
    "output_event": "MyNewEvent",
    "prompt_template": MY_STEP_TEMPLATE,
    "template_variables": ["input_text"],
},
```

## Adding a Frontend Page

**Files to modify**: `frontend/app/pages/`

Nuxt uses file-based routing. Create a `.vue` file and it automatically becomes a route:

| File | Route |
|------|-------|
| `pages/my-page.vue` | `/my-page` |
| `pages/items/index.vue` | `/items` |
| `pages/items/[id].vue` | `/items/:id` |

### Basic page template

```vue
<script setup lang="ts">
const config = useRuntimeConfig()

interface MyData {
  id: number
  name: string
}

const items = ref<MyData[]>([])
const loading = ref(true)

onMounted(async () => {
  try {
    const data = await $fetch<{ results: MyData[] }>(
      `${config.public.apiBase}/api/my-endpoint`
    )
    items.value = data.results
  } finally {
    loading.value = false
  }
})
</script>

<template>
  <div class="container mx-auto p-6">
    <h1 class="text-2xl font-bold mb-4">My Page</h1>
    <div v-if="loading">Loading...</div>
    <div v-else>
      <!-- render items -->
    </div>
  </div>
</template>
```

No router configuration is needed. The page is live after a dev server refresh.

## Adding a New Model Integration

**Files to modify**: new file in `src/`, `docker-compose.yml`

### 1. Create a client module

Add a new file in `src/` (e.g., `src/my_service_client.py`):

```python
import os
import httpx

MY_SERVICE_URL = os.environ.get("MY_SERVICE_URL", "http://localhost:9000")

async def call_my_service(input_data: str) -> dict:
    async with httpx.AsyncClient(timeout=30.0) as client:
        response = await client.post(
            f"{MY_SERVICE_URL}/predict",
            json={"input": input_data},
        )
        response.raise_for_status()
        return response.json()

async def check_my_service_health(url: str = None) -> bool:
    url = url or MY_SERVICE_URL
    try:
        async with httpx.AsyncClient(timeout=5.0) as client:
            resp = await client.get(f"{url}/health")
            return resp.status_code == 200
    except Exception:
        return False
```

### 2. Add the environment variable

Add the URL to the `x-common-env` block in `docker-compose.yml`:

```yaml
x-common-env: &common-env
  # ... existing vars ...
  MY_SERVICE_URL: http://my-service:9000
```

### 3. Wire it into a workflow or endpoint

Import the client in your workflow step or API endpoint and call it.

## Adding a Celery Task

**Files to modify**: `src/tasks.py`, `src/celery_app.py` (if scheduled)

### 1. Define the task

```python
@celery_app.task(name="my_new_task", queue="waywo")
def my_new_task(param1: str, param2: int = 10):
    """Task docstring."""
    # task logic here
    return {"status": "success", "result": "..."}
```

### 2. Trigger from an API endpoint

```python
@app.post("/api/my-task", tags=["my-feature"])
async def trigger_my_task():
    task = my_new_task.delay(param1="value")
    return {"task_id": task.id, "status": "queued"}
```

### 3. Add to beat schedule (optional)

If the task should run on a schedule, add it to the beat configuration in `src/celery_app.py`.

## Checklist

When adding a new feature, verify:

- [ ] API endpoint works in Swagger UI (`/docs`)
- [ ] Pydantic models validate input correctly
- [ ] Database operations have proper error handling
- [ ] New workflow steps appear on the `/prompts` page
- [ ] Frontend page renders and fetches data
- [ ] Code is formatted with `make black`
- [ ] Tests cover the new functionality
