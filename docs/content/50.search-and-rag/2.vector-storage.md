---
title: Vector Storage
description: How sqlite-vector is loaded, configured, and used to store and index project embeddings inside SQLite.
navigation.icon: i-lucide-database
---

# Vector Storage

WAYWO stores vector embeddings directly in SQLite using the [sqlite-vector](https://github.com/nicholasgasior/sqlite-vector) extension. There is no external vector database -- embeddings live alongside the project data in a single `waywo.db` file.

## Extension Loading

The sqlite-vector extension is loaded on **every** database connection via a SQLAlchemy event listener in `src/database.py`:

```python
@event.listens_for(engine, "connect")
def set_sqlite_pragma(dbapi_connection, connection_record):
    # Load the extension binary
    ext_path = importlib.resources.files("sqlite_vector.binaries") / "vector"
    dbapi_connection.enable_load_extension(True)
    dbapi_connection.load_extension(str(ext_path))
    dbapi_connection.enable_load_extension(False)

    # Initialize the vector context for this connection
    cursor.execute(
        "SELECT vector_init('waywo_projects', 'description_embedding', "
        "'type=FLOAT32,dimension=4096,distance=COSINE')"
    )
```

`vector_init()` must be called on each new connection to register the column metadata sqlite-vector needs for search.

## Vector Configuration

| Parameter | Value | Notes |
|-----------|-------|-------|
| Data type | `FLOAT32` | 32-bit IEEE floats, stored as little-endian binary |
| Dimensions | `4096` | Matches llama-embed-nemotron-8b output size |
| Distance metric | `COSINE` | Range 0 (identical) to 2 (opposite) |
| Column | `description_embedding` | Nullable `BLOB` on `waywo_projects` table |

## Embedding Column

The `WaywoProjectDB` model defines the embedding column as an optional binary blob:

```python
description_embedding: Mapped[Optional[bytes]] = mapped_column(
    LargeBinary, nullable=True
)
```

Not every project has an embedding. Projects processed before the embedding service was available, or where the service call failed, will have `NULL` in this column and will not appear in search results.

## Binary Conversion Helpers

Embeddings travel between Python lists and SQLite blobs through two helper functions in `src/embedding_client.py`:

```python
def embedding_to_blob(embedding: list[float]) -> bytes:
    """Pack a list of floats into a little-endian FLOAT32 binary blob."""
    return struct.pack(f"<{len(embedding)}f", *embedding)

def blob_to_embedding(blob: bytes) -> list[float]:
    """Unpack a binary blob back into a list of floats."""
    num_floats = len(blob) // 4
    return list(struct.unpack(f"<{num_floats}f", blob))
```

## Embedding Text Construction

The text that gets embedded is a concatenation of three project fields, built by `create_embedding_text()`:

```python
def create_embedding_text(title, description, hashtags):
    hashtag_str = " ".join(f"#{tag}" for tag in hashtags) if hashtags else ""
    return f"{title}\n{description}\n{hashtag_str}".strip()
```

This ensures the embedding captures the project name, what it does, and its topic tags.

## Vector Quantization Index

For faster approximate nearest neighbor search, sqlite-vector supports a quantization index. The `build_vector_index()` function in `src/database.py` creates or rebuilds it:

```python
def build_vector_index():
    session.execute(
        text("SELECT vector_quantize('waywo_projects', 'description_embedding')")
    )
```

- Safe to call multiple times (rebuilds in place)
- Skips automatically if no embeddings exist yet
- Should be called after bulk-adding or updating embeddings
- Available via the admin API: `POST /api/admin/rebuild-vector-index`

::note
The current search implementation uses `vector_full_scan` (brute-force) rather than the quantized index. This ensures accuracy for the current dataset size and avoids cross-connection state issues with quantized indexes.
::
